# Package 追跡

## 1) `bitbake -e` で DEPENDS / RDEPENDS の出どころを逆引きする図

### まず全体像

```
(bblayers.conf で有効化された Layers)
  ├─ base recipe (.bb)
  ├─ class (.bbclass: inherit で混入)
  ├─ config (distro/machine/*.conf, local.conf)
  └─ appends (.bbappend: 差分注入)
        ↓ すべての上書き・append/remove を評価
      bitbake -e <pn>
        ↓
   最終的な DEPENDS/RDEPENDS と
   「どのファイルの何行が最後に効いたか」の痕跡が出る
```

### 実際の逆引き手順（現場で使える手順）

1. まず環境を吐く

```bash
bitbake -e <pn> | less
```

2. `less` の中で検索（/ を押して）

* `^DEPENDS=`
* `^RDEPENDS:`（多くは `RDEPENDS:${PN}=` みたいな形）
* `^RRECOMMENDS:`（任意依存）

3. “どこから来たか”を見るコツ
   `bitbake -e` の出力は **変数の直前/直後に「履歴コメント」**が付くことが多い。見つけたら、その近くにある **set/append/remove されたファイルパスと行番号**が「犯人」。

イメージ（雰囲気）：

```
# $DEPENDS [..]
#   set /path/to/meta-foo/recipes-xxx/bar/bar.bb:23
#   append /path/to/meta-custom/recipes-xxx/bar/bar.bbappend:7
DEPENDS="openssl zlib ..."
```

> もし履歴コメントが薄い環境でも、少なくとも「最終値」は必ず出る。
> 出どころ特定は次の `bitbake-layers` と合わせ技にする。

### bbappend が効いてるかを即チェック（合わせ技）

```bash
bitbake-layers show-appends | grep -E '<pn>|<recipe名>'
```

* 「どの `.bbappend` がそのレシピに当たっているか」を一覧で出せる
* `bitbake -e` で見えた最終値と突き合わせる

### “依存関係のグラフ化”もできる（俯瞰したいとき）

```bash
bitbake -g <pn-or-image>
# pn-depends.dot / package-depends.dot などができる
```

* **DEPENDS**（ビルド依存）と **RDEPENDS**（実行依存）を「塊」で見たいときに強い

---

## 2) Package を必要最低限に選定するアプローチ

「最小化」は精神論で削ると壊れる。**観測 → 分類 → 制御**の順でやるのが現実的。

### ステップ0：最小化の基準を先に決める

* 必須機能（例：ネットワーク、SSH、ログ、更新、時刻同期）
* 必須ハード（I2C/SPI/GPIO など）
* 必須運用（systemd 必要？ busybox だけで良い？）
* デバッグは入れる？（dbg/dev は通常入れない）

ここが曖昧だと、削ったあとに“必要だった”が頻発して時間が溶ける。

### ステップ1：最小の土台から始める

* `core-image-minimal` か WRLinux の最小イメージ相当をベースに
* いきなり “full” 系から削るのは負け筋（依存が絡みすぎる）

### ステップ2：何が入っているかを“正”で把握する（観測）

ビルド後に rootfs に入ったパッケージを確認する（手段は環境次第）：

* rpm 系ならターゲットで `rpm -qa`
* deb 系なら `dpkg -l`
* ipk 系なら `opkg list-installed`

Yocto 側でも `pkgdata` を見れば追える（環境によりコマンドは多少違うが、発想は同じ）：

* 「最終 rootfs に入った一覧」をまず確定させる

### ステップ3：削り方の優先順位（壊れにくい順）

1. **RRECOMMENDS を切る（安全度高）**

   * “あると便利”を落とすだけなので壊れにくい
   * 手段例：

     * `NO_RECOMMENDATIONS = "1"`（全体で推奨を無視）
     * `BAD_RECOMMENDATIONS += "foo bar"`（特定だけ落とす）

2. **packagegroup を分割する（本命）**

   * `packagegroup-custom-base` / `packagegroup-custom-net` / `packagegroup-custom-drivers` みたいに切る
   * イメージは packagegroup だけを `IMAGE_INSTALL` する
   * 最小化のコントロール点が “束” になるので管理しやすい

3. **IMAGE_INSTALL から remove / EXCLUDE（強いが壊しやすい）**

   * `IMAGE_INSTALL:remove = "foo"`
   * `PACKAGE_EXCLUDE = "foo"`（最後の手段寄り。依存で再び入るのを強制排除できるが地雷にもなる）

### ステップ4：落としていい/ダメの判断を機械化（超重要）

「要る・要らない」を感覚でやらず、**依存の根拠**で判断する。

* あるパッケージ `X` を削りたい
  → `X` が **誰の RDEPENDS** で入ってきたかを辿る

  * `bitbake -e <入れてる側>` で `RDEPENDS` を確認
  * `bitbake-layers show-appends` で差分注入を確認
  * `bitbake -g <image>` で “どこから来たか”を俯瞰

この「出どころ追跡」ができると、最小化は作業になる（運ゲーじゃなくなる）。

---

## まとめ（次の一手）

* **逆引き**：`bitbake -e <pn>` で最終値 → 近傍の履歴コメントで犯人特定
* **bbappend特定**：`bitbake-layers show-appends`
* **最小化**：最小イメージ → まず推奨依存（RRECOMMENDS）を切る → packagegroup を分割して制御点を作る

ボトルネックはたぶんここで、**「rootfs に入った理由」を追えないと削れない**。
追えるようにした瞬間、最小化は一気に楽になる。
