# 事故らない勘所

"知っておくと後悔しないこと”を、重要度順にまとめる。

---

## 1) 変更が効かない時の“三点確認”は反射でやる

何か変えたのに反映されないとき、**悩む前に必ずこの順で確認**。

1. **レイヤが有効か**
   `bblayers.conf` に入ってる？ `bitbake-layers show-layers`
2. **bbappendが当たってるか**
   `bitbake-layers show-appends | grep <pn>`
3. **キャッシュに負けてないか**
   `bitbake -c clean <pn>` → ダメなら `-c cleansstate`

ここを外すと時間が蒸発する。

---

## 2) “設計として書く場所”を間違えない（最重要）

* **local.conf**：実験場（短命）
* **bbappend / レイヤ**：恒久設計（本命）
* **image直書き**：最小構成のときだけ
* **packagegroup**：規模が出たら必須

> 迷ったら「これは将来も同じ？」
> YES → レイヤ／bbappend
> NO → local.conf

---

## 3) 依存は「理由が説明できる」ものだけ入れる

**最小化のコツ**は削ることじゃない。**入れる理由を言語化**すること。

* RDEPENDS：**無いと死ぬ理由を言える？**
* RRECOMMENDS：**無くても動く？**
* DEPENDS：**ビルド時に何が要る？**

説明できない依存は、たいてい不要か場所が違う。

---

## 4) featureは“条件”、packagegroupは“実体”

* featureを書いても**何も入らない**
* 実体は**packagegroupのRDEPENDS**

設計の型：

```
feature（条件）
 → packagegroup（実体の束）
   → image（箱）
```

この型を崩すと、後で必ず破綻する。

---

## 5) systemd / module / sysctl は“枠”に乗せる

**手作業は禁止**。全部ビルドに組み込む。

* systemd：`inherit systemd` / `SYSTEMD_AUTO_ENABLE`
* module：`modules-load.d` + `modprobe.d`
* sysctl：`/etc/sysctl.d/*.conf`
* tmpfiles：`/etc/tmpfiles.d/*.conf`

「起動後にコマンド叩く」は負け筋。

---

## 6) “誰が入れたか”を追える状態を保つ

* `bitbake -e`：最終値と由来
* `bitbake -g`：依存の俯瞰
* `rpm -qf` / `opkg whatdepends`：所有関係

**追えない構成＝保守不能**。

---

## 7) 変更単位は“小さく、1理由1コミット”

Yoctoは変更点が拡散しやすい。

* 1 bbappend = 1目的
* packagegroupは機能単位で分割
* コミットメッセージに「なぜ」を書く

後任（未来の自分）を助ける。

---

## 8) バージョン固定は“最後の手段”

* `PREFERRED_VERSION` は慎重に
* まずは **DISTRO_FEATURES / PACKAGECONFIG** で制御
* 固定したら**解除条件**も一緒に決める

固定は借金。返済計画を立ててから。

---

## 9) オフライン・再現性は早めに考える

* `DL_DIR` / `SSTATE_DIR` 共有
* ソースの取得方法（tarball化/ミラー）
* ビルド手順のドキュメント化

**「来月も同じものが作れる」**が商用の最低条件。

---

## 10) “正常系”を一度決めてから最適化する

* まず動く最小構成を決める
* そこから追加・削減
* 途中で方向転換しない

Yoctoは**同時にいじると因果が見えなくなる**。

---

# 設計レビュー用チェックリスト（Yocto / WRLinux）

## 0. ゴール・スコープ

* [ ] 何を満たすための変更か（機能要件・非機能要件：容量/起動時間/セキュリティ/保守性）が1文で言える
* [ ] 影響範囲（対象MACHINE / 対象IMAGE / 対象製品SKU）が明確
* [ ] “やらないこと”が書いてある（要件膨張防止）

## 1. 変更の置き場所（責務分離）

* [ ] `local.conf` に恒久変更を書いていない（実験だけ）
* [ ] 自社差分は `meta-custom` 等のレイヤに閉じている
* [ ] feature条件（DISTRO/MACHINE）と実体（packagegroup/image）が分離されている
* [ ] 同じ目的の変更が複数箇所に散っていない（重複定義がない）

## 2. レイヤ運用

* [ ] `bblayers.conf` に追加レイヤが正しく登録されている
* [ ] レイヤ優先順位（`BBFILE_PRIORITY`）が意図通り
* [ ] `.bbappend` の適用対象が正しい（レシピ名/バージョン一致）
* [ ] 依存する外部レイヤ（meta-oe等）のバージョン前提が明記されている

## 3. 依存関係（DEPENDS / RDEPENDS / RRECOMMENDS）

* [ ] `DEPENDS` はビルドに必要なものだけ（理由が説明できる）
* [ ] 実行時に必要なものは `RDEPENDS:${PN}` にある（抜けがない）
* [ ] “あると便利”は `RRECOMMENDS` で、必須にしていない
* [ ] 依存増加がイメージサイズ・起動時間に与える影響が説明されている
* [ ] 依存の出どころを `bitbake -e` / `bitbake -g` で追跡できる状態

## 4. パッケージ選定・最小化

* [ ] `packagegroup` が機能単位で分割されている（base/net/drivers/debug等）
* [ ] `NO_RECOMMENDATIONS` / `BAD_RECOMMENDATIONS` の扱い方針が一貫
* [ ] `PACKAGE_EXCLUDE` を乱用していない（使うなら理由が強い）
* [ ] dev/dbg パッケージが本番イメージに入っていない（必要なら明確な理由）

## 5. 設定の入れ方（再現性）

* [ ] `/etc` 配下は `do_install()` でファイルとして配布している（手作業なし）
* [ ] 設定は可能なら「設定専用パッケージ（foo-config）」に分離されている
* [ ] systemd unit は `inherit systemd` と `SYSTEMD_*` で管理されている
* [ ] モジュール自動ロードは `modules-load.d`、パラメータは `modprobe.d` で管理
* [ ] sysctl/limits/tmpfiles はそれぞれの `.d` 仕組みに乗っている

## 6. バージョン固定・互換性

* [ ] `PREFERRED_VERSION` を入れた場合、解除条件（いつ外すか）が書かれている
* [ ] API/ABI 変更がある依存（glibc/openssl/systemd等）の影響を評価している
* [ ] MACHINE切替でも成立するか（少なくとも壊れ方が予測できる）

## 7. ビルド・キャッシュ・再現性

* [ ] `DL_DIR` / `SSTATE_DIR` の運用（共有/固定/オフライン）が決まっている
* [ ] クリーン手順が用意されている（clean/cleansstate の使い分け）
* [ ] ビルド手順がREADME等に残っている（誰がやっても再現可能）

## 8. 検証と受け入れ基準

* [ ] 受け入れ基準が具体的（例：起動後に `modprobe mydrv` 成功、サービス起動確認）
* [ ] ログ/確認コマンドが用意されている（dmesg, systemctl, rpm/opkg 等）
* [ ] 失敗時の切り戻し（前バージョン/feature off）が可能

---

# bbappend の “やっていい / ダメ” 一覧

## ✅ やっていい（推奨：正攻法で追えるやつ）

### 1) 既存レシピへの「最小限の差分」追加

* `SRC_URI += "file://patch.patch"` でパッチ適用
* `FILESEXTRAPATHS:prepend := "${THISDIR}/${PN}:"` でファイル探索追加
* `do_install:append()` で設定ファイル追加（/etc, unit, modprobe.d 等）

### 2) 依存や設定の追記（理由が明確な場合）

* `RDEPENDS:${PN} += "..."`（実行時に必要）
* `DEPENDS += "..."`（ビルド時に必要）
* `PACKAGECONFIG:append = " foo"`（機能ON/OFF）
* `EXTRA_OE*` 系の追加（configure/cmake/make のオプション）

### 3) image / packagegroup の整理

* `IMAGE_INSTALL:append = " packagegroup-xxx"`
* packagegroup レシピを作って、image からは束だけ参照
* feature条件付き追加（`bb.utils.contains()`）※読みやすく最小限に

### 4) systemd の正しい統合

* `inherit systemd`
* `SYSTEMD_SERVICE:${PN}` / `SYSTEMD_AUTO_ENABLE:${PN}` の指定
* unitファイル配置を `do_install()` に寄せる

---

## ⚠️ 条件付きでOK（やるならルール化）

### 1) `:remove` の使用

* `RDEPENDS:${PN}:remove = "foo"`
  → 本当に不要か、依存グラフで確認してから。副作用が出やすい。

### 2) “設定上書き” の投入

* 既存 `/etc/foo.conf` を差し替える
  → 目的・差分・互換性（既存値の扱い）を明文化。可能なら `foo-config` へ分離。

### 3) ビルドフラグの強制

* `CFLAGS:append` / `LDFLAGS:append`
  → 影響範囲が広い。必要性が強い場合のみ。

---

## ❌ ダメ（将来必ず壊れる/追えなくなる）

### 1) `local.conf` で済む実験を bbappend に雑に入れる

* 「一時しのぎのデバッグ設定」を恒久化しがち
  → 変更理由が消える。撤去されずに残る。

### 2) 本体レシピを“全部置き換える”ような bbappend

* upstreamの更新耐性ゼロになる
  → 小さなパッチに分解しろ。無理なら自前レシピ化。

### 3) `PACKAGE_EXCLUDE` 乱用・無根拠な強制排除

* 依存で必要なのに強制排除すると、ランタイムで爆発する
  → 原因（どこがRDEPENDSしてるか）を直すのが先。

### 4) rootfs への手作業前提（post-install でコマンド叩く等）

* ビルドと実機状態が乖離して再現性が死ぬ
  → ファイル配置 + systemd/modprobe の枠で完結させる。

### 5) 巨大な条件分岐スパゲッティ

* `bb.utils.contains()` が多段・ネストし始めたら黄色信号
  → packagegroup分割、machine/distro conf に寄せる。

---

## “レビューで一発合格”するための短い合言葉

* **差分は小さく**（bbappendはパッチ＋最小追記）
* **実体は束で**（packagegroup）
* **設定はファイルで**（do_installで配る）
* **追跡できることが正義**（bitbake -e / show-appends で出どころが見える）
